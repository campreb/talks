<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Ruby Tricks – NZ Ruby Talks</title>
    <link href="/stylesheets/application-ff6d8108.css" media="screen" rel="stylesheet" type="text/css" />

    <script type="text/javascript" src="//use.typekit.net/lpd5kis.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
  </head>
  <body>

    <aside>
      <a href="/" class="logo">
        <img alt="NZ Ruby Talks" width="180" height="180" src="/images/logo-1be683a4.png" />
        NZ Ruby Talks
      </a>

      <nav>
        <a href="/">Talks</a>
        <a href="https://github.com/nzruby/talks">Add your talk</a>
        <a href="http://ruby.org.nz/">About NZ Ruby</a>
      </nav>
    </aside>

    <article>
      
  <div class="talk">
    <h1>Ruby Tricks</h1>

    <div class="meta">
  <span class="by">
    by <span class="author">Pete Nicholls</span>
  </span>

  <span class="on">
    on <time datetime="2014-06-19T00:00:00+12:00">
      19 Jun 2014
     </time>  
  </span>
  
  <span class="at">
    at <span class="venue">Christchurch Ruby</span>  
  </span>
</div>

    <h2>The weirdest way to write an empty string</h2>
<pre class="highlight ruby"><span class="sx">%%%%%%</span><span class="o">%</span>
</pre>
<p>Explanation (try this out in <code>pry</code> or <code>irb</code>):</p>
<pre class="highlight ruby"><span class="sx">%( a string with the "%" syntax )</span>
<span class="c1"># =&gt; " a string with the \"%\" syntax "</span>
<span class="sx">%! can use almost any character to delineate a string !</span>
<span class="c1"># =&gt; " can use almost any character to delineate a string "</span>
<span class="sx">%% even a percent sign itself %</span>
<span class="c1"># =&gt; " even a percent sign itself "</span>
<span class="sx">%%%</span> <span class="o">==</span> <span class="s2">""</span>
<span class="c1"># =&gt; true</span>
<span class="s2">"strings also have a percent method %s"</span> <span class="o">%</span> <span class="s2">"for formatting values"</span>
<span class="c1"># =&gt; "strings also have a method for formatting values"</span>
<span class="s2">""</span> <span class="o">%</span> <span class="s2">""</span>
<span class="c1"># =&gt; ""</span>
<span class="sx">%%%</span> <span class="o">%</span> <span class="sx">%%%</span>
<span class="c1"># =&gt; ""</span>
<span class="sx">%%%%%%</span><span class="o">%</span>
<span class="c1"># =&gt; ""</span>
</pre>
<h2>Hash.new takes a block</h2>

<p>Anything specified in the block to <code>Hash.new</code> is considered to be the default value.</p>
<pre class="highlight ruby"><span class="c1"># true by default</span>
<span class="n">permissions</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="kp">true</span> <span class="p">}</span>
<span class="n">permissions</span><span class="o">[</span><span class="ss">:jim</span><span class="o">]</span>             <span class="c1"># =&gt; true</span>
<span class="n">permissions</span><span class="o">[</span><span class="ss">:dwight</span><span class="o">]</span>          <span class="c1"># =&gt; true</span>
<span class="n">permissions</span><span class="o">[</span><span class="ss">:dwight</span><span class="o">]</span> <span class="o">=</span> <span class="kp">false</span>
<span class="n">permissions</span><span class="o">[</span><span class="ss">:dwight</span><span class="o">]</span>          <span class="c1"># =&gt; false</span>
</pre>
<p>More precisely, the block is called whenever a key lookup fails.</p>

<p>This has some interesting characteristics:</p>
<pre class="highlight ruby"><span class="n">upper</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="nb">hash</span><span class="p">,</span> <span class="n">key</span><span class="o">|</span> <span class="n">key</span><span class="p">.</span><span class="nf">upcase</span> <span class="p">}</span>
<span class="n">upper</span><span class="o">[</span><span class="s1">'word'</span><span class="o">]</span>                <span class="c1"># =&gt; "WORD"</span>
<span class="n">upper</span><span class="o">[</span><span class="s1">'class'</span><span class="o">]</span>               <span class="c1"># =&gt; "CLASS"</span>
<span class="n">upper</span><span class="o">[</span><span class="s1">'iphone'</span><span class="o">]</span>              <span class="c1"># =&gt; "IPHONE"</span>
<span class="n">upper</span><span class="o">[</span><span class="s1">'iphone'</span><span class="o">]</span> <span class="o">=</span> <span class="s1">'iPHONE'</span>
<span class="n">upper</span><span class="o">[</span><span class="s1">'iphone'</span><span class="o">]</span>              <span class="c1"># =&gt; "iPHONE"</span>
</pre>
<p>Two values are passed to the block, <code>hash</code> (a reference to the hash itself), and <code>key</code>.</p>

<p>You can use these values to set the value of a key at the moment the lookup fails:</p>
<pre class="highlight ruby"><span class="c1"># No need to check for nil</span>
<span class="n">observers</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="nb">hash</span><span class="p">,</span> <span class="n">key</span><span class="o">|</span> <span class="nb">hash</span><span class="o">[</span><span class="n">key</span><span class="o">]</span> <span class="o">=</span> <span class="o">[]</span> <span class="p">}</span>
<span class="n">observers</span>
<span class="c1"># =&gt; {}</span>
<span class="n">observers</span><span class="o">[</span><span class="ss">:event_a</span><span class="o">]</span> <span class="o">&lt;&lt;</span> <span class="ss">:listener_a</span>
<span class="n">observers</span><span class="o">[</span><span class="ss">:event_a</span><span class="o">]</span> <span class="o">&lt;&lt;</span> <span class="ss">:listener_b</span>
<span class="n">observers</span><span class="o">[</span><span class="ss">:event_b</span><span class="o">]</span> <span class="o">&lt;&lt;</span> <span class="ss">:listener_a</span>
<span class="n">observers</span>
<span class="c1"># =&gt; {</span>
<span class="c1">#   :event_a =&gt; [:listener_a, :listener_b],</span>
<span class="c1">#   :event_b =&gt; [:listener_a]</span>
<span class="c1"># }</span>
</pre>
<p>You can use this trick to memoize:</p>
<pre class="highlight ruby"><span class="k">def</span> <span class="nf">regular_ol_fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">n</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="nf">.</span><span class="mi">1</span><span class="p">).</span><span class="nf">include?</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">regular_ol_fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">regular_ol_fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">awesome_fib</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">cache</span><span class="p">,</span> <span class="n">n</span><span class="o">|</span>
 <span class="n">cache</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">awesome_fib</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">awesome_fib</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span>
<span class="k">end</span>

<span class="n">awesome_fib</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">awesome_fib</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">awesome_fib</span><span class="o">[</span><span class="mi">34</span><span class="o">]</span>      <span class="c1"># took 0.047 milliseconds</span>
<span class="n">regular_ol_fib</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span>   <span class="c1"># took 4.5 seconds</span>
<span class="n">awesome_fib</span><span class="o">[</span><span class="mi">3000</span><span class="o">]</span>    <span class="c1"># took 3.69 milliseconds</span>
<span class="n">regular_ol_fib</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span> <span class="c1"># don't even try this</span>
</pre>
<h2>Autovivification</h2>

<p>One interesting thing about the <code>Hash.new</code> block is that you can get a reference to it from the hash instance itself:</p>
<pre class="highlight ruby"><span class="n">hash_with_block</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="n">various_happenings</span> <span class="p">}</span>
<span class="n">hash_with_block</span><span class="p">.</span><span class="nf">default_proc</span> <span class="c1"># =&gt; #&lt;Proc:0x007faf3ac93d08&gt;</span>
</pre>
<p>Because <code>Hash.new</code> yields the hash itself, you can refer to the block <em>inside the block itself</em>:</p>
<pre class="highlight ruby"><span class="n">autovivification</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="nb">hash</span><span class="p">,</span> <span class="n">key</span><span class="o">|</span> <span class="nb">hash</span><span class="o">[</span><span class="n">key</span><span class="o">]</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">hash</span><span class="p">.</span><span class="nf">default_proc</span><span class="p">)</span> <span class="p">}</span>
<span class="n">autovivification</span><span class="o">[</span><span class="ss">:keys</span><span class="o">][</span><span class="ss">:dont</span><span class="o">][</span><span class="ss">:even</span><span class="o">][</span><span class="ss">:exist</span><span class="o">][</span><span class="ss">:until</span><span class="o">]</span> <span class="o">=</span> <span class="ss">:now</span>

<span class="n">autovivification</span> <span class="c1"># =&gt; {:keys=&gt;{:dont=&gt;{:even=&gt;{:exist=&gt;{:until=&gt;:now}}}}}</span>
</pre>
<p>(<em>Auto</em> means “self” and <em>vivify</em> means “give life to”.)</p>

<h2>Shipping data with code</h2>

<p>When you use the keyword <code>__END__</code>, Ruby considers the script to be over at that point.</p>

<p>Anything written beyond it will be ignored:</p>
<pre class="highlight ruby"><span class="c1"># some ruby code</span>
<span class="cp">__END__
this will never be interpreted
</span></pre>
<p>However, you can access this content with the <code>DATA</code> object:</p>
<pre class="highlight ruby"><span class="nb">puts</span> <span class="no">DATA</span><span class="p">.</span><span class="nf">read</span> <span class="c1"># Will print "Hello there!"</span>
<span class="cp">__END__
Hello there!
</span></pre>
<p>You can use this to include templates, data, or anything else you like along with your script.</p>
<pre class="highlight ruby"><span class="n">quotes</span> <span class="o">=</span> <span class="no">DATA</span><span class="p">.</span><span class="nf">to_a</span>
<span class="nb">puts</span> <span class="s2">"Random Chuck Norris quote:"</span>
<span class="nb">puts</span> <span class="n">quotes</span><span class="p">.</span><span class="nf">shuffle</span><span class="p">.</span><span class="nf">pop</span>

<span class="cp">__END__
When Chuck Norris throws exceptions, it’s across the room.
All arrays Chuck Norris declares are of infinite size, because Chuck Norris knows no bounds.
Chuck Norris doesn’t have disk latency because the hard drive knows to hurry the hell up.
Chuck Norris writes code that optimizes itself.
Chuck Norris can’t test for equality because he has no equal.
</span></pre>
  </div>


    </article>

    <script src="/javascripts/upcoming-e8099929.js" type="text/javascript"></script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-44220139-1', 'ruby.org.nz');
  ga('send', 'pageview');

</script>
  </body>
</html>
